package skrifer.github.com.code;

import java.util.Map;

public class HashMap_ {

    public static void main(String[] args) {


        //jdk1.7
        //数组 + 链表
        //如果扩容 -> 实际是数组扩容（添加元素时会判断是否需要扩容，如果要扩容默认新数组容量是2倍) -> 得到新数组 ->双重循环便利老数组(内层循环是为了遍历数组元素是链表)
        // -> 此处链表中的元素和数组的元素（不是链表的数组元素）将平铺展开（双重循环将所有元素置于同一水平面上），通过hash值和新数组容量重新计算在新数组中的下标-> 将新的元素赋值到新数组的对应下标上去(如果hash值相同则该元素为链表结构，并且采用头部插入法，后进的元素置于链表头部)
        //括完容的数组 与 原数组可能完全不一样（所有的元素都通过元素hash值 和新数组容量计算得到的新下标）,普通元素的位置发生了变化，链表元素的也发生了变化


        //jdk1.8
        //数组+链表+红黑树(链表大小超过8之后)
        //扩容数组规则与 1.7 一样
        //如果数组元素时普通元素或者链表元素 则与1.7相同
        //如果数组元素时红黑树,循环红黑树元素，每个元素的处理逻辑与上面相同
        // 唯一的区别当某个链表的元素超过了8个(有8个hash相同的元素)时，链表会变成红黑树(以此加速元素的筛选便利 方便搜索定位元素)
    }
}
